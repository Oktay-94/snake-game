"""
Enterprise Software Factory - Core Module
Version: 1.0.0
Author: Senior Web Developer
Description: Production-ready enterprise software component with comprehensive error handling and logging
"""

import logging
from typing import Any, Dict, List, Optional, Union
from datetime import datetime
from functools import wraps
import json


class EnterpriseLogger:
    """Centralized logging system for enterprise applications"""
    
    def __init__(self, name: str):
        self.logger = logging.getLogger(name)
        self.logger.setLevel(logging.INFO)
        
        if not self.logger.handlers:
            handler = logging.StreamHandler()
            formatter = logging.Formatter(
                '%(asctime)s - %(name)s - %(levelname)s - %(message)s'
            )
            handler.setFormatter(formatter)
            self.logger.addHandler(handler)
    
    def info(self, message: str, **kwargs):
        self.logger.info(f"{message} {json.dumps(kwargs) if kwargs else ''}")
    
    def error(self, message: str, **kwargs):
        self.logger.error(f"{message} {json.dumps(kwargs) if kwargs else ''}")
    
    def warning(self, message: str, **kwargs):
        self.logger.warning(f"{message} {json.dumps(kwargs) if kwargs else ''}")


class ValidationError(Exception):
    """Custom exception for validation errors"""
    pass


class DataProcessor:
    """Core data processing engine for enterprise applications"""
    
    def __init__(self):
        self.logger = EnterpriseLogger(__name__)
        self.cache: Dict[str, Any] = {}
        self.created_at = datetime.now()
    
    def validate_input(self, data: Any, required_fields: Optional[List[str]] = None) -> bool:
        """
        Validates input data against required fields
        
        Args:
            data: Input data to validate
            required_fields: List of required field names
            
        Returns:
            bool: True if validation passes
            
        Raises:
            ValidationError: If validation fails
        """
        if data is None:
            raise ValidationError("Data cannot be None")
        
        if required_fields and isinstance(data, dict):
            missing_fields = [field for field in required_fields if field not in data]
            if missing_fields:
                raise ValidationError(f"Missing required fields: {missing_fields}")
        
        return True
    
    def process(self, data: Dict[str, Any], transform_fn=None) -> Dict[str, Any]:
        """
        Processes data with optional transformation function
        
        Args:
            data: Input data dictionary
            transform_fn: Optional transformation function
            
        Returns:
            Processed data dictionary
        """
        try:
            self.validate_input(data)
            self.logger.info("Processing data", data_keys=list(data.keys()))
            
            result = data.copy()
            result['processed_at'] = datetime.now().isoformat()
            result['processor_id'] = id(self)
            
            if transform_fn and callable(transform_fn):
                result = transform_fn(result)
            
            self.logger.info("Data processed successfully")
            return result
            
        except Exception as e:
            self.logger.error(f"Processing failed: {str(e)}")
            raise
    
    def cache_data(self, key: str, value: Any) -> None:
        """Caches data with given key"""
        self.cache[key] = {
            'value': value,
            'cached_at': datetime.now().isoformat()
        }
        self.logger.info(f"Data cached with key: {key}")
    
    def get_cached_data(self, key: str) -> Optional[Any]:
        """Retrieves cached data by key"""
        cached = self.cache.get(key)
        if cached:
            self.logger.info(f"Cache hit for key: {key}")
            return cached['value']
        self.logger.warning(f"Cache miss for key: {key}")
        return None
    
    def clear_cache(self) -> None:
        """Clears all cached data"""
        self.cache.clear()
        self.logger.info("Cache cleared")


def retry_on_failure(max_retries: int = 3):
    """Decorator for retrying failed operations"""
    def decorator(func):
        @wraps(func)
        def wrapper(*args, **kwargs):
            logger = EnterpriseLogger(func.__name__)
            for attempt in range(max_retries):
                try:
                    return func(*args, **kwargs)
                except Exception as e:
                    logger.warning(f"Attempt {attempt + 1} failed: {str(e)}")
                    if attempt == max_retries - 1:
                        logger.error(f"All {max_retries} attempts failed")
                        raise
            return None
        return wrapper
    return decorator


class EnterpriseService:
    """Main enterprise service orchestrator"""
    
    def __init__(self, config: Optional[Dict[str, Any]] = None):
        self.config = config or {}
        self.logger = EnterpriseLogger(__name__)
        self.processor = DataProcessor()
        self.initialized_at = datetime.now()
        self.logger.info("Enterprise service initialized", config=self.config)
    
    @retry_on_failure(max_retries=3)
    def execute(self, operation: str, data: Dict[str, Any]) -> Dict[str, Any]:
        """
        Executes a business operation with retry logic
        
        Args:
            operation: Operation identifier
            data: Operation input data
            
        Returns:
            Operation result dictionary
        """
        self.logger.info(f"Executing operation: {operation}")
        
        result = self.processor.process(data)
        result['operation'] = operation
        result['status'] = 'success'
        
        return result
    
    def get_status(self) -> Dict[str, Any]:
        """Returns current service status"""
        return {
            'status': 'operational',
            'initialized_at': self.initialized_at.isoformat(),
            'uptime_seconds': (datetime.now() - self.initialized_at).total_seconds(),
            'cache_size': len(self.processor.cache)
        }


if __name__ == '__main__':
    service = EnterpriseService({'environment': 'production'})
    test_data = {'key': 'value', 'timestamp': datetime.now().isoformat()}
    result = service.execute('test_operation', test_data)
    print(json.dumps(result, indent=2, default=str))
